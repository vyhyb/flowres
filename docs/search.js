window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "flowres", "modulename": "flowres", "kind": "module", "doc": "<p>Flowres - A package for flow resistivity measurements according to ISO 9053-1</p>\n\n<p>This package provides a set of tools for measuring flow resistivity of\nporous materials according to ISO 9053-1. The package assumes three main\ncomponents, which are defined as protocols:</p>\n\n<ul>\n<li>PressureSensor: A protocol for pressure sensors</li>\n<li>FlowSensor: A protocol for flow sensors</li>\n<li>FlowActuator: A protocol for flow actuators</li>\n</ul>\n\n<p>Having these protocols defined, the package provides a set of functions\nfor measuring flow resistivity, including error propagation, data\nprocessing, and exporting data to CSV files.</p>\n\n<p>The repository contains also example implementations of the protocols for\nspecific sensors and actuators, but mostly, that part is left for the user.</p>\n\n<h2 id=\"installation\">Installation</h2>\n\n<p>It is currently not possible to install this library using <code>pip</code> or <code>conda</code>,\nplease use the latest <a href=\"https://github.com/vyhyb/flowres/releases\">released package</a>\ninstead and install using <a href=\"https://packaging.python.org/en/latest/tutorials/installing-packages/\"><code>pip</code> locally</a>.</p>\n\n<h2 id=\"documentation\">Documentation</h2>\n\n<p>Documentation can be found <a href=\"https://vyhyb.github.io/flowres/\">here</a>.</p>\n\n<h2 id=\"usage\">Usage</h2>\n\n<p>An example script based on the provided example implementations of the protocols.</p>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">flowres</span> <span class=\"kn\">import</span> <span class=\"n\">measurement_loop</span><span class=\"p\">,</span> <span class=\"n\">export_csv</span><span class=\"p\">,</span> <span class=\"n\">flow_rate_array</span><span class=\"p\">,</span> <span class=\"n\">iso_calculation</span>\n<span class=\"kn\">from</span> <span class=\"nn\">sensors</span> <span class=\"kn\">import</span> <span class=\"n\">FestoFlowActuator</span><span class=\"p\">,</span> <span class=\"n\">TSI4100FlowMeter</span><span class=\"p\">,</span> <span class=\"n\">PressureSensor</span>\n<span class=\"kn\">import</span> <span class=\"nn\">os</span>\n<span class=\"kn\">import</span> <span class=\"nn\">numpy</span> <span class=\"k\">as</span> <span class=\"nn\">np</span>\n<span class=\"kn\">from</span> <span class=\"nn\">time</span> <span class=\"kn\">import</span> <span class=\"n\">strftime</span>\n\n<span class=\"c1\"># initiation of the sensor</span>\n<span class=\"n\">flow_sensor</span> <span class=\"o\">=</span> <span class=\"n\">TSI4100FlowMeter</span><span class=\"p\">(</span><span class=\"s2\">&quot;COM1&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">flow_actuator</span> <span class=\"o\">=</span> <span class=\"n\">FestoFlowActuator</span><span class=\"p\">()</span>\n<span class=\"n\">pressure_sensor</span> <span class=\"o\">=</span> <span class=\"n\">PressureSensor</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># specimen definition</span>\n<span class=\"n\">name</span> <span class=\"o\">=</span> <span class=\"s2\">&quot;test&quot;</span>\n<span class=\"n\">timestamp</span> <span class=\"o\">=</span> <span class=\"n\">strftime</span><span class=\"p\">(</span><span class=\"s2\">&quot;%y-%m-</span><span class=\"si\">%d</span><span class=\"s2\">_%H-%M&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">radius</span> <span class=\"o\">=</span> <span class=\"mf\">0.0225</span>\n\n<span class=\"n\">start_flow</span> <span class=\"o\">=</span> <span class=\"mf\">0.5</span>\n<span class=\"n\">end_flow</span> <span class=\"o\">=</span> <span class=\"mf\">1.5</span>\n<span class=\"n\">steps</span> <span class=\"o\">=</span> <span class=\"mi\">100</span>\n<span class=\"n\">two_way</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>\n<span class=\"n\">target_flow_rates</span> <span class=\"o\">=</span> <span class=\"n\">flow_rate_array</span><span class=\"p\">(</span><span class=\"n\">start_flow</span><span class=\"p\">,</span> <span class=\"n\">end_flow</span><span class=\"p\">,</span> <span class=\"n\">steps</span><span class=\"p\">,</span> <span class=\"n\">two_way</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># measurement</span>\n<span class=\"k\">try</span><span class=\"p\">:</span>\n    <span class=\"n\">flow_sensor</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">()</span>\n    <span class=\"n\">pressure_sensor</span><span class=\"o\">.</span><span class=\"n\">open</span><span class=\"p\">()</span>\n\n    <span class=\"n\">pressure</span><span class=\"p\">,</span> <span class=\"n\">flow_rate</span> <span class=\"o\">=</span> <span class=\"n\">measurement_loop</span><span class=\"p\">(</span><span class=\"n\">pressure_sensor</span><span class=\"p\">,</span> <span class=\"n\">flow_sensor</span><span class=\"p\">,</span> <span class=\"n\">flow_actuator</span><span class=\"p\">,</span> <span class=\"n\">target_flow_rates</span><span class=\"p\">)</span>\n    <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"p\">((</span><span class=\"n\">pressure</span><span class=\"p\">,</span> <span class=\"n\">flow_rate</span><span class=\"p\">),</span> <span class=\"n\">axis</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">export_csv</span><span class=\"p\">(</span><span class=\"n\">data</span><span class=\"p\">,</span> <span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{</span><span class=\"n\">timestamp</span><span class=\"si\">}</span><span class=\"s2\">_</span><span class=\"si\">{</span><span class=\"n\">name</span><span class=\"si\">}</span><span class=\"s2\">.csv&quot;</span><span class=\"p\">)</span>\n<span class=\"k\">finally</span><span class=\"p\">:</span>\n    <span class=\"n\">flow_sensor</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n    <span class=\"n\">pressure_sensor</span><span class=\"o\">.</span><span class=\"n\">close</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># post processing</span>\n<span class=\"n\">diameter</span> <span class=\"o\">=</span> <span class=\"n\">radius</span><span class=\"o\">*</span><span class=\"mi\">2</span>\n<span class=\"n\">surface_area</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">radius</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n<span class=\"n\">results</span> <span class=\"o\">=</span> <span class=\"n\">iso_calculation</span><span class=\"p\">(</span><span class=\"n\">flow_rates</span><span class=\"o\">=</span><span class=\"n\">flow_rate</span><span class=\"p\">,</span> <span class=\"n\">pressures</span><span class=\"o\">=</span><span class=\"n\">pressure</span><span class=\"p\">,</span> <span class=\"n\">surface_area</span><span class=\"o\">=</span><span class=\"n\">surface_area</span><span class=\"p\">)</span>\n<span class=\"n\">results</span><span class=\"o\">.</span><span class=\"n\">export</span><span class=\"p\">(</span><span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{</span><span class=\"n\">timestamp</span><span class=\"si\">}</span><span class=\"s2\">_</span><span class=\"si\">{</span><span class=\"n\">name</span><span class=\"si\">}</span><span class=\"s2\">&quot;</span><span class=\"p\">)</span>\n\n<span class=\"c1\"># plot the results together with the regression</span>\n<span class=\"kn\">import</span> <span class=\"nn\">matplotlib.pyplot</span> <span class=\"k\">as</span> <span class=\"nn\">plt</span>\n<span class=\"kn\">from</span> <span class=\"nn\">scipy.stats</span> <span class=\"kn\">import</span> <span class=\"n\">linregress</span>\n\n<span class=\"n\">flow_rate_m3s</span> <span class=\"o\">=</span> <span class=\"n\">flow_rate</span> <span class=\"o\">/</span> <span class=\"mi\">1000</span> <span class=\"o\">/</span> <span class=\"mi\">60</span> <span class=\"c1\"># L/min to m^3/s</span>\n<span class=\"n\">velocity_mms</span> <span class=\"o\">=</span> <span class=\"n\">flow_rate_m3s</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">pi</span><span class=\"o\">*</span><span class=\"n\">radius</span><span class=\"o\">**</span><span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"mi\">1000</span> <span class=\"c1\"># m^3/s to mm/s</span>\n\n<span class=\"c1\"># linear regression</span>\n<span class=\"n\">reg</span> <span class=\"o\">=</span> <span class=\"n\">linregress</span><span class=\"p\">(</span><span class=\"n\">pressure</span><span class=\"p\">,</span> <span class=\"n\">velocity_mms</span><span class=\"p\">)</span>\n<span class=\"n\">pressure_reg</span> <span class=\"o\">=</span> <span class=\"n\">np</span><span class=\"o\">.</span><span class=\"n\">array</span><span class=\"p\">([</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">pressure</span><span class=\"p\">[</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]])</span>\n<span class=\"n\">velocity_reg</span> <span class=\"o\">=</span> <span class=\"n\">pressure_reg</span><span class=\"o\">*</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">slope</span>\n<span class=\"c1\"># std envelopes</span>\n<span class=\"n\">velocitystd_reg_top</span> <span class=\"o\">=</span> <span class=\"n\">pressure_reg</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">slope</span><span class=\"o\">+</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">stderr</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">intercept</span><span class=\"o\">+</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">intercept_stderr</span>\n<span class=\"n\">velocitystd_reg_bottom</span> <span class=\"o\">=</span> <span class=\"n\">pressure_reg</span><span class=\"o\">*</span><span class=\"p\">(</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">slope</span><span class=\"o\">-</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">stderr</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">intercept</span><span class=\"o\">-</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">intercept_stderr</span>\n\n<span class=\"c1\"># plots</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">scatter</span><span class=\"p\">(</span><span class=\"n\">pressure</span><span class=\"p\">,</span><span class=\"n\">velocity_mms</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"s2\">&quot;measured points&quot;</span><span class=\"p\">);</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">fill_between</span><span class=\"p\">(</span><span class=\"n\">pressure_reg</span><span class=\"p\">,</span> <span class=\"n\">velocitystd_reg_top</span><span class=\"p\">,</span> <span class=\"n\">velocitystd_reg_bottom</span><span class=\"p\">,</span> <span class=\"n\">alpha</span><span class=\"o\">=</span><span class=\"mf\">0.7</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;regression +- stderr&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">plot</span><span class=\"p\">(</span><span class=\"n\">pressure_reg</span><span class=\"p\">,</span> <span class=\"n\">velocity_reg</span><span class=\"p\">,</span> <span class=\"n\">label</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"s2\">&quot;regression</span>\n<span class=\"p\">(</span><span class=\"n\">offset</span> <span class=\"p\">{</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">intercept</span><span class=\"p\">:</span><span class=\"mf\">.3</span><span class=\"n\">f</span><span class=\"p\">}</span> <span class=\"o\">+-</span> <span class=\"p\">{</span><span class=\"n\">reg</span><span class=\"o\">.</span><span class=\"n\">intercept_stderr</span><span class=\"p\">:</span><span class=\"mf\">.3</span><span class=\"n\">f</span><span class=\"p\">})</span><span class=\"s2\">&quot;)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">legend</span><span class=\"p\">()</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">xlabel</span><span class=\"p\">(</span><span class=\"s2\">&quot;pressure[Pa]&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">ylabel</span><span class=\"p\">(</span><span class=\"s2\">&quot;velocity[mm/s]&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">savefig</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"s2\">&quot;</span><span class=\"si\">{</span><span class=\"n\">timestamp</span><span class=\"si\">}</span><span class=\"s2\">_</span><span class=\"si\">{</span><span class=\"n\">name</span><span class=\"si\">}</span><span class=\"s2\">.png&quot;</span><span class=\"p\">)</span>\n<span class=\"n\">plt</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre>\n</div>\n\n<p>Refer to the <code>measurement.ipynb</code> notebook for a more detailed example.</p>\n\n<h2 id=\"author\">Author</h2>\n\n<ul>\n<li><p><a href=\"https://www.fce.vutbr.cz/o-fakulte/lide/david-jun-12801/\">David Jun</a></p>\n\n<p>PhD student at <a href=\"https://www.vutbr.cz/en/\">Brno University of Technology</a>.</p></li>\n</ul>\n\n<h2 id=\"contributing\">Contributing</h2>\n\n<p>Pull requests are welcome. For any changes, please open an issue first\nto discuss what you would like to change.</p>\n\n<p>Please make sure to update tests as appropriate.</p>\n\n<h2 id=\"license\">License</h2>\n\n<p><a href=\"https://choosealicense.com/licenses/gpl-3.0/\">GNU GPLv3</a></p>\n\n<p>Flowres - A package for flow resistivity measurements according to ISO 9053-1\nCopyright (C) 2025 David Jun</p>\n\n<p>This program is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.</p>\n\n<p>This program is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.</p>\n\n<p>You should have received a copy of the GNU General Public License\nalong with this program.  If not, see <a href=\"https://www.gnu.org/licenses/\">https://www.gnu.org/licenses/</a>.</p>\n\n<h2 id=\"references\">References</h2>\n\n<p>[1] \u010cSN EN ISO 9053-1 - Akustika - Stanoven\u00ed odporu proti proud\u011bn\u00ed vzduchu - \u010d\u00e1st 1: Metoda statick\u00e9ho proud\u011bn\u00ed vzduchu, manual, Praha., 2019.</p>\n"}, {"fullname": "flowres.flow_pressure_measurement", "modulename": "flowres.flow_pressure_measurement", "kind": "module", "doc": "<p>Module for the flow and pressure measurement using the flow actuator, \npressure sensor and flow sensor. The module provides functions to perform\nthe measurement and calibration of the flow actuator for reaching a target flow.</p>\n"}, {"fullname": "flowres.flow_pressure_measurement.PressureSensor", "modulename": "flowres.flow_pressure_measurement", "qualname": "PressureSensor", "kind": "class", "doc": "<p>Protocol for pressure sensors.</p>\n", "bases": "typing.Protocol"}, {"fullname": "flowres.flow_pressure_measurement.PressureSensor.read_pressure", "modulename": "flowres.flow_pressure_measurement", "qualname": "PressureSensor.read_pressure", "kind": "function", "doc": "<p>Read the pressure from the sensor with the given number \nof averaged readings.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">num_readings</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "flowres.flow_pressure_measurement.FlowSensor", "modulename": "flowres.flow_pressure_measurement", "qualname": "FlowSensor", "kind": "class", "doc": "<p>Protocol for flow sensors.</p>\n", "bases": "typing.Protocol"}, {"fullname": "flowres.flow_pressure_measurement.FlowSensor.read_flow", "modulename": "flowres.flow_pressure_measurement", "qualname": "FlowSensor.read_flow", "kind": "function", "doc": "<p>Read the flow from the sensor with the given number\nof averaged readings.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">num_readings</span><span class=\"o\">=</span><span class=\"mi\">1</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "flowres.flow_pressure_measurement.FlowActuator", "modulename": "flowres.flow_pressure_measurement", "qualname": "FlowActuator", "kind": "class", "doc": "<p>Protocol for flow actuators.</p>\n", "bases": "typing.Protocol"}, {"fullname": "flowres.flow_pressure_measurement.FlowActuator.set_voltage", "modulename": "flowres.flow_pressure_measurement", "qualname": "FlowActuator.set_voltage", "kind": "function", "doc": "<p>Set the voltage of the actuator to the given value.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">voltage</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.flow_pressure_measurement.FlowActuator.change_voltage", "modulename": "flowres.flow_pressure_measurement", "qualname": "FlowActuator.change_voltage", "kind": "function", "doc": "<p>Change the voltage of the actuator by the given amount.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"bp\">self</span>, </span><span class=\"param\"><span class=\"n\">voltage_change</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.flow_pressure_measurement.measurement_loop", "modulename": "flowres.flow_pressure_measurement", "qualname": "measurement_loop", "kind": "function", "doc": "<p>Perform the measurement loop for the given flow rates using the\npressure sensor, flow sensor and flow actuator. The function returns\nthe arrays of pressure and flow rates.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pressure_sensor</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">flow_pressure_measurement</span><span class=\"o\">.</span><span class=\"n\">PressureSensor</span>,</span><span class=\"param\">\t<span class=\"n\">flow_sensor</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">flow_pressure_measurement</span><span class=\"o\">.</span><span class=\"n\">FlowSensor</span>,</span><span class=\"param\">\t<span class=\"n\">flow_actuator</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">flow_pressure_measurement</span><span class=\"o\">.</span><span class=\"n\">FlowActuator</span>,</span><span class=\"param\">\t<span class=\"n\">flow_rates</span><span class=\"p\">:</span> <span class=\"n\">List</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">calibration_array</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">3.5</span>       <span class=\"p\">,</span>  <span class=\"mf\">3.50207151</span><span class=\"p\">,</span>  <span class=\"mf\">3.50412962</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">4.9998767</span> <span class=\"p\">,</span>\n         <span class=\"mf\">4.9999178</span> <span class=\"p\">,</span>  <span class=\"mf\">4.9999589</span> <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">16.79099815</span><span class=\"p\">,</span> <span class=\"mf\">16.76374403</span><span class=\"p\">,</span> <span class=\"mf\">16.73657443</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.53845895</span><span class=\"p\">,</span>\n         <span class=\"mf\">0.53844233</span><span class=\"p\">,</span>  <span class=\"mf\">0.53842631</span><span class=\"p\">]])</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "flowres.flow_pressure_measurement.measurement", "modulename": "flowres.flow_pressure_measurement", "qualname": "measurement", "kind": "function", "doc": "<p>Perform the measurement for the given target flow rate using the\npressure sensor, flow sensor and flow actuator. The function returns\nthe pressure and flow rate.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">pressure_sensor</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">flow_pressure_measurement</span><span class=\"o\">.</span><span class=\"n\">PressureSensor</span>,</span><span class=\"param\">\t<span class=\"n\">flow_sensor</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">flow_pressure_measurement</span><span class=\"o\">.</span><span class=\"n\">FlowSensor</span>,</span><span class=\"param\">\t<span class=\"n\">flow_actuator</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">flow_pressure_measurement</span><span class=\"o\">.</span><span class=\"n\">FlowActuator</span>,</span><span class=\"param\">\t<span class=\"n\">target_flow_rate</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">max_iterations</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">tolerance_stability</span><span class=\"o\">=</span><span class=\"mf\">0.001</span>,</span><span class=\"param\">\t<span class=\"n\">calibration_array</span><span class=\"o\">=</span><span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">3.5</span>       <span class=\"p\">,</span>  <span class=\"mf\">3.50207151</span><span class=\"p\">,</span>  <span class=\"mf\">3.50412962</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">4.9998767</span> <span class=\"p\">,</span>\n         <span class=\"mf\">4.9999178</span> <span class=\"p\">,</span>  <span class=\"mf\">4.9999589</span> <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">16.79099815</span><span class=\"p\">,</span> <span class=\"mf\">16.76374403</span><span class=\"p\">,</span> <span class=\"mf\">16.73657443</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.53845895</span><span class=\"p\">,</span>\n         <span class=\"mf\">0.53844233</span><span class=\"p\">,</span>  <span class=\"mf\">0.53842631</span><span class=\"p\">]])</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]</span>:</span></span>", "funcdef": "def"}, {"fullname": "flowres.flow_pressure_measurement.voltage_guess", "modulename": "flowres.flow_pressure_measurement", "qualname": "voltage_guess", "kind": "function", "doc": "<p>Guess the voltage for the flow actuator to reach the target flow\nbased on the calibration data.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">target_flow</span><span class=\"p\">:</span> <span class=\"nb\">float</span>,</span><span class=\"param\">\t<span class=\"n\">calibration_array</span><span class=\"p\">:</span> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span> <span class=\"o\">=</span> <span class=\"n\">array</span><span class=\"p\">([[</span> <span class=\"mf\">3.5</span>       <span class=\"p\">,</span>  <span class=\"mf\">3.50207151</span><span class=\"p\">,</span>  <span class=\"mf\">3.50412962</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">4.9998767</span> <span class=\"p\">,</span>\n         <span class=\"mf\">4.9999178</span> <span class=\"p\">,</span>  <span class=\"mf\">4.9999589</span> <span class=\"p\">],</span>\n       <span class=\"p\">[</span><span class=\"mf\">16.79099815</span><span class=\"p\">,</span> <span class=\"mf\">16.76374403</span><span class=\"p\">,</span> <span class=\"mf\">16.73657443</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">,</span>  <span class=\"mf\">0.53845895</span><span class=\"p\">,</span>\n         <span class=\"mf\">0.53844233</span><span class=\"p\">,</span>  <span class=\"mf\">0.53842631</span><span class=\"p\">]])</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">float</span>:</span></span>", "funcdef": "def"}, {"fullname": "flowres.flow_pressure_measurement.calibrate_flow_actuator", "modulename": "flowres.flow_pressure_measurement", "qualname": "calibrate_flow_actuator", "kind": "function", "doc": "<p>Calibrate the flow actuator using the flow sensor for the given\nvoltage range and number of steps. The function saves the calibration\ndata to the file and returns the calibration data.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">flow_actuator</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">flow_pressure_measurement</span><span class=\"o\">.</span><span class=\"n\">FlowActuator</span>,</span><span class=\"param\">\t<span class=\"n\">flow_sensor</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">flow_pressure_measurement</span><span class=\"o\">.</span><span class=\"n\">FlowSensor</span>,</span><span class=\"param\">\t<span class=\"n\">voltage_range</span><span class=\"p\">:</span> <span class=\"n\">Tuple</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">steps</span><span class=\"o\">=</span><span class=\"mi\">100</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span><span class=\"o\">=</span><span class=\"s1\">&#39;dac_calibration.npy&#39;</span></span><span class=\"return-annotation\">) -> <span class=\"n\">numpy</span><span class=\"o\">.</span><span class=\"n\">ndarray</span>:</span></span>", "funcdef": "def"}, {"fullname": "flowres.misc", "modulename": "flowres.misc", "kind": "module", "doc": "<p>This module provides a set of utility functions for the flowres package.</p>\n"}, {"fullname": "flowres.misc.FlowActuator", "modulename": "flowres.misc", "qualname": "FlowActuator", "kind": "class", "doc": "<p>Base class for protocol classes.</p>\n\n<p>Protocol classes are defined as::</p>\n\n<pre><code>class Proto(Protocol):\n    def meth(self) -&gt; int:\n        ...\n</code></pre>\n\n<p>Such classes are primarily used with static type checkers that recognize\nstructural subtyping (static duck-typing), for example::</p>\n\n<pre><code>class C:\n    def meth(self) -&gt; int:\n        return 0\n\ndef func(x: Proto) -&gt; int:\n    return x.meth()\n\nfunc(C())  # Passes static type check\n</code></pre>\n\n<p>See PEP 544 for details. Protocol classes decorated with\n@typing.runtime_checkable act as simple-minded runtime protocols that check\nonly the presence of given attributes, ignoring their type signatures.\nProtocol classes can be generic, they are defined as::</p>\n\n<pre><code>class GenProto(Protocol[T]):\n    def meth(self) -&gt; T:\n        ...\n</code></pre>\n", "bases": "typing.Protocol"}, {"fullname": "flowres.misc.progressbar", "modulename": "flowres.misc", "qualname": "progressbar", "kind": "function", "doc": "<p>A simple progress bar function to show the progress of the measurement loop.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">current_value</span>, </span><span class=\"param\"><span class=\"n\">total_value</span>, </span><span class=\"param\"><span class=\"n\">bar_lengh</span>, </span><span class=\"param\"><span class=\"n\">progress_char</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.misc.export_csv", "modulename": "flowres.misc", "qualname": "export_csv", "kind": "function", "doc": "<p>Export the data to a CSV file with the given filename and delimiter.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">data</span>, </span><span class=\"param\"><span class=\"n\">filename</span>, </span><span class=\"param\"><span class=\"n\">parent</span><span class=\"o\">=</span><span class=\"s1\">&#39;.&#39;</span>, </span><span class=\"param\"><span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">&#39;,&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.misc.flow_rate_array", "modulename": "flowres.misc", "qualname": "flow_rate_array", "kind": "function", "doc": "<p>Generate an array of flow rates between the given start and stop values\nwith the given number of steps. The two_way parameter determines whether\nthe flow rates should be generated in a two-way manner.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">start</span>, </span><span class=\"param\"><span class=\"n\">stop</span>, </span><span class=\"param\"><span class=\"n\">steps</span>, </span><span class=\"param\"><span class=\"n\">two_way</span><span class=\"o\">=</span><span class=\"kc\">False</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.misc.export_results", "modulename": "flowres.misc", "qualname": "export_results", "kind": "function", "doc": "<p>Export the results to a CSV file with the given filename and delimiter.</p>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">results</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">processing</span><span class=\"o\">.</span><span class=\"n\">Results</span>,</span><span class=\"param\">\t<span class=\"n\">filename</span>,</span><span class=\"param\">\t<span class=\"n\">parent</span><span class=\"o\">=</span><span class=\"s1\">&#39;.&#39;</span>,</span><span class=\"param\">\t<span class=\"n\">delimiter</span><span class=\"o\">=</span><span class=\"s1\">&#39;,&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.misc.final_beep", "modulename": "flowres.misc", "qualname": "final_beep", "kind": "function", "doc": "<p>Perform a final beep sequence with the flow actuator.</p>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">flow_actuator</span><span class=\"p\">:</span> <span class=\"n\">flowres</span><span class=\"o\">.</span><span class=\"n\">misc</span><span class=\"o\">.</span><span class=\"n\">FlowActuator</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.processing", "modulename": "flowres.processing", "kind": "module", "doc": "<p>This module contains the functions for processing the data from\nthe ISO 9053-1 related measurements.</p>\n"}, {"fullname": "flowres.processing.flow_rate_conversions", "modulename": "flowres.processing", "qualname": "flow_rate_conversions", "kind": "function", "doc": "<p>Convert flow rates to m^3/s.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>flow_rates</strong> (ndarray):\nThe array of flow rates to convert.</li>\n<li><strong>input_dim</strong> (str, optional):\nThe input dimension of the flow rates. Defaults to 'l/min'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>rates</strong> (ndarray):\nThe array of flow rates converted to m^3/s.</li>\n</ul>\n\n<h6 id=\"raises\">Raises</h6>\n\n<ul>\n<li><strong>ValueError</strong>: If the input dimension is not implemented.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">flow_rates</span>, </span><span class=\"param\"><span class=\"n\">input_dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;l/min&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.processing.regression", "modulename": "flowres.processing", "qualname": "regression", "kind": "function", "doc": "<p>Perform a linear regression on the flow rates and pressures.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>flow_rates</strong> (ndarray):\nThe array of flow rates.</li>\n<li><strong>pressures</strong> (ndarray):\nThe array of pressures.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>reg</strong> (LinregressResult):\nThe result of the linear regression.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">flow_rates</span>, </span><span class=\"param\"><span class=\"n\">pressures</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.processing.airflow_resistance", "modulename": "flowres.processing", "qualname": "airflow_resistance", "kind": "function", "doc": "<p>Calculate the airflow resistance from the regression.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>reg</strong> (LinregressResult):\nThe result of the linear regression.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>flow_resistance</strong> (float):\nThe airflow resistance</li>\n<li><strong>stderr</strong> (float):\nThe standard error of the regression.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">reg</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.processing.specific_airflow_resistance", "modulename": "flowres.processing", "qualname": "specific_airflow_resistance", "kind": "function", "doc": "<p>Calculate the specific airflow resistance.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>flow_resistance</strong> (float):\nThe airflow resistance.</li>\n<li><strong>surface_area</strong> (float):\nThe surface area of the specimen.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>specific_flow_resistance</strong> (float):\nThe specific airflow resistance.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">flow_resistance</span>, </span><span class=\"param\"><span class=\"n\">surface_area</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.processing.airflow_resistivity", "modulename": "flowres.processing", "qualname": "airflow_resistivity", "kind": "function", "doc": "<p>Calculate the airflow resistivity.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>specific_flow_resistance</strong> (float):\nThe specific airflow resistance.</li>\n<li><strong>thickness</strong> (float):\nThe thickness of the specimen.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>flow_resistivity</strong> (float):\nThe airflow resistivity</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">specific_flow_resistance</span>, </span><span class=\"param\"><span class=\"n\">thickness</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.processing.velocity_boundaries", "modulename": "flowres.processing", "qualname": "velocity_boundaries", "kind": "function", "doc": "<p>Calculate the minimum and maximum velocity boundaries.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>flow_rates</strong> (ndarray):\nThe array of flow rates.</li>\n<li><strong>surface_area</strong> (float):\nThe surface area of the specimen.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>vel_bound</strong> (Tuple[float, float]):\nThe minimum and maximum velocity boundaries</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code condensed\">(<span class=\"param\"><span class=\"n\">flow_rates</span>, </span><span class=\"param\"><span class=\"n\">surface_area</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}, {"fullname": "flowres.processing.iso_calculation", "modulename": "flowres.processing", "qualname": "iso_calculation", "kind": "function", "doc": "<p>Perform the ISO 9053-1 calculation.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>flow_rates</strong> (ndarray):\nThe array of flow rates.</li>\n<li><strong>pressures</strong> (ndarray):\nThe array of pressures.</li>\n<li><strong>surface_area</strong> (float or ndarray):\nThe surface area of the specimen.</li>\n<li><strong>thickness</strong> (float or ndarray):\nThe thickness of the specimen.</li>\n<li><strong>input_flow_dim</strong> (str, optional):\nThe input dimension of the flow rates. Defaults to '\nl/min'.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>results</strong> (Results):\nThe results of the calculation.</li>\n</ul>\n", "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">flow_rates</span>,</span><span class=\"param\">\t<span class=\"n\">pressures</span>,</span><span class=\"param\">\t<span class=\"n\">surface_area</span>,</span><span class=\"param\">\t<span class=\"n\">thickness</span>,</span><span class=\"param\">\t<span class=\"n\">input_flow_dim</span><span class=\"o\">=</span><span class=\"s1\">&#39;l/min&#39;</span></span><span class=\"return-annotation\">):</span></span>", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();